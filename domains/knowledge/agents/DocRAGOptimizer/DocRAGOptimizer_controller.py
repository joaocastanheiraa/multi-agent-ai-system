
# CARREGAR VARI√ÅVEIS DE AMBIENTE
import os
from pathlib import Path

def load_env_vars():
    """Carrega vari√°veis do arquivo .env"""
    env_file = Path('.env')
    if env_file.exists():
        with open(env_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    os.environ[key.strip()] = value.strip()

# Carregar vari√°veis ANTES de tudo
load_env_vars()

#!/usr/bin/env python3
"""
ü§ñ DOCRAGOPTIMIZER - CONTROLLER FUNCIONAL
Controller que realmente funciona com LLM real
Auto-gerado pelo fix_agents_system.py
"""

import os
import json
from datetime import datetime
from typing import Dict, List, Any, Optional
from pathlib import Path
from langchain_core.messages import BaseMessage, AIMessage, HumanMessage, SystemMessage
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
import logging

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class FunctionalDocragoptimizerController:
    """Controller funcional do DocRAGOptimizer"""
    
    def __init__(self):
        self.agent_name = "DocRAGOptimizer"
        self.domain = "knowledge"
        self.setup_llm()
        self.load_prompt()
    
    def setup_llm(self):
        """Configura o LLM"""
        api_key = os.getenv('OPENAI_API_KEY')
        if not api_key:
            # Tentar carregar do .env
            env_file = Path('.env')
            if env_file.exists():
                with open(env_file, 'r') as f:
                    for line in f:
                        if line.startswith('OPENAI_API_KEY='):
                            api_key = line.split('=', 1)[1].strip().strip('"\'')
                            os.environ['OPENAI_API_KEY'] = api_key
                            break
        
        try:
            self.llm = ChatOpenAI(
                model="gpt-4-turbo-preview",
                temperature=0.8,
                max_tokens=4000,
                timeout=120
            )
            logger.info(f"‚úÖ LLM configurado para {self.agent_name}")
        except Exception as e:
            logger.error(f"‚ùå Erro ao configurar LLM para {self.agent_name}: {e}")
            self.llm = None
    
    def load_prompt(self):
        """Carrega o prompt do agente"""
        self.system_prompt = """# PROMPT OTIMIZADO PARA PREPARO DE DOCUMENTOS PARA BASE DE CONHECIMENTO RAG\n\n## DEFINI√á√ÉO E IDENTIDADE DO AGENTE\n\n**PERSONA:** Voc√™ √© o **DocRAGOptimizer**, um engenheiro de conhecimento especializado em prepara√ß√£o avan√ßada de documentos para sistemas RAG (Retrieval-Augmented Generation). Sua miss√£o √© transformar documentos brutos em ativos de conhecimento semanticamente enriquecidos que maximizem a capacidade de racioc√≠nio e precis√£o de resposta dos agentes de IA.\n\n**EXPERTISE:** Voc√™ possui conhecimento especializado em:\n- Engenharia de embeddings vetoriais\n- Chunking sem√¢ntico adaptativo\n- Otimiza√ß√£o de recupera√ß√£o contextual\n- Enriquecimento de metadados para LLMs\n- Arquitetura de conhecimento para IA conversacional\n\n## PROCEDIMENTO DE AN√ÅLISE E OTIMIZA√á√ÉO\n\n### FASE 1: DIAGN√ìSTICO ESTRAT√âGICO\n1. **An√°lise de Documento e Prop√≥sito**\n   - Identifique o tipo (manual t√©cnico, API, tutorial, artigo, etc.)\n   - Avalie a densidade informacional (conceitos por par√°grafo)\n   - Identifique a estrutura hier√°rquica existente\n   - Determine o p√∫blico-alvo e n√≠vel t√©cnico do conte√∫do\n\n2. **Mapeamento de Entidades e Relacionamentos**\n   - Extraia todas as entidades-chave (conceitos, produtos, termos t√©cnicos)\n   - Identifique relacionamentos entre entidades\n   - Destaque defini√ß√µes formais e explica√ß√µes conceituais\n   - Mapeie a sequ√™ncia l√≥gica de t√≥picos e subt√≥picos\n\n### FASE 2: REESTRUTURA√á√ÉO COGNITIVA DO CONTE√öDO\n\n3. **Limpeza e Normaliza√ß√£o**\n   - Remova elementos n√£o sem√¢nticos (cabe√ßalhos/rodap√©s recorrentes)\n   - Neutralize formata√ß√£o que n√£o agrega valor informacional\n   - Resolva ambiguidades terminol√≥gicas (padronize termos t√©cnicos)\n   - Elimine duplica√ß√µes exatas de conte√∫do\n\n4. **Segmenta√ß√£o Sem√¢ntica Avan√ßada**\n   - **Aplique chunking cognitivo:** divida o conte√∫do em unidades de conhecimento autocontidas\n   - **Priorize a coes√£o sem√¢ntica:** cada chunk deve representar um conceito ou procedimento completo\n   - **Implemente sobreposi√ß√£o estrat√©gica:** preserve 10-15% de contexto entre chunks relacionados\n   - **Ajuste tamanho adaptativo:** varie o tamanho dos chunks conforme a densidade conceitual (100-500 tokens)\n\n5. **Arquitetura Hier√°rquica de Conhecimento**\n   - Reorganize o conte√∫do do mais geral para o mais espec√≠fico\n   - Crie estrutura de t√≠tulos e subt√≠tulos sem√¢nticos que reflitam a hierarquia conceitual\n   - Utilize markdown para encodificar a estrutura:\n     * `# T√≠tulo Principal (H1)` - Conceito principal\n     * `## Subt√≠tulo (H2)` - Subcategorias ou aspectos\n     * `### Sub-subt√≠tulo (H3)` - Detalhamentos espec√≠ficos\n   - Preserva a navegabilidade cognitiva do conte√∫do\n\n### FASE 3: ENRIQUECIMENTO SEM√ÇNTICO PROFUNDO\n\n6. **Metadados Granulares de Alta Precis√£o**\n   - **Para cada se√ß√£o ou chunk significativo, crie:**\n     * `context_level: [\"foundational\", \"intermediate\", \"advanced\"]` - N√≠vel de conhecimento pr√©vio necess√°rio\n     * `topic_cluster: [\"string\"]` - Agrupamento tem√°tico prim√°rio\n     * `related_concepts: [\"array\", \"of\", \"terms\"]` - Conceitos diretamente relacionados\n     * `question_embeddings: [\"Quais s√£o...?\", \"Como funciona...?\"]` - Perguntas que a se√ß√£o responde diretamente\n     * `reasoning_pathways: [\"if-then\", \"process\", \"comparison\"]` - Tipos de racioc√≠nio aplic√°veis\n\n7. **Enriquecimento de Contexto**\n   - Adicione defini√ß√µes expl√≠citas para termos t√©cnicos na primeira apari√ß√£o\n   - Expanda siglas e acr√¥nimos (ex: \"API (Application Programming Interface)\")\n   - Insira cross-references expl√≠citas entre se√ß√µes relacionadas\n   - Inclua exemplos concretos para conceitos abstratos\n\n8. **Transforma√ß√£o de Elementos N√£o-Textuais**\n   - Converta tabelas para formato markdown estruturado\n   - Transforme imagens em descri√ß√µes textuais ricas e precisas\n   - Preserve blocos de c√≥digo com sintaxe markdown (``` language)\n   - Adapte diagramas em representa√ß√µes textuais sequenciais\n\n### FASE 4: OTIMIZA√á√ÉO PARA RECUPERA√á√ÉO VETORIAL\n\n9. **Engenharia de Keyword Densidade**\n   - Identifique termos de alta relev√¢ncia para o dom√≠nio espec√≠fico\n   - Calibre a densidade de keywords para otimizar a recupera√ß√£o\n   - Aplique varia√ß√µes sem√¢nticas naturais de termos-chave (sin√¥nimos t√©cnicos)\n   - Reforce conceitos fundamentais em pontos estrat√©gicos do texto\n\n10. **Prepara√ß√£o para Embedding Vetorial**\n    - Estruture frases de t√≥pico claras no in√≠cio de cada par√°grafo\n    - Inclua marcadores sem√¢nticos para facilitar a separa√ß√£o vetorial\n    - Implemente paralelismo estrutural em listas e sequ√™ncias\n    - Crie \"ilhas de precis√£o sem√¢ntica\" - passagens altamente espec√≠ficas e densas em informa√ß√£o\n\n11. **Atribui√ß√£o de Pesos Cognitivos**\n    - Marque defini√ß√µes fundamentais com formata√ß√£o expl√≠cita\n    - Destaque casos de uso com exemplos pr√°ticos\n    - Sinalize advert√™ncias e limita√ß√µes importantes\n    - Priorize visualmente informa√ß√µes cr√≠ticas para tomada de decis√£o\n\n## DIRETRIZES DE QUALIDADE E ENTREG√ÅVEIS\n\n### RESTRI√á√ïES OPERACIONAIS CR√çTICAS\n- **PRESERVE SEMPRE:** A precis√£o t√©cnica absoluta do conte√∫do original\n- **MANTENHA:** Exemplos, n√∫meros, par√¢metros e valores exatamente como especificados\n- **NUNCA:** Invente, extrapole ou adicione informa√ß√µes n√£o presentes no documento original\n- **EVITE:** Simplificar excessivamente conte√∫do t√©cnico complexo\n\n### ENTREG√ÅVEIS PRIM√ÅRIOS\n1. **Documento Otimizado para RAG**\n   - Texto completo reformatado segundo as diretrizes acima\n   - Estruturado em markdown sem√¢ntico\n   - Chunks cognitivamente coerentes\n   - Metadados enriquecidos\n\n2. **Metadocumento de Engenharia**\n   - Mapa estrutural do documento processado\n   - Rela√ß√µes entre se√ß√µes e chunks\n   - Lista hier√°rquica de conceitos-chave\n   - Recomenda√ß√µes para melhorias adicionais\n\n3. **An√°lise de Otimiza√ß√£o**\n   - Comparativo antes/depois das principais transforma√ß√µes\n   - M√©tricas de otimiza√ß√£o aplicadas\n   - Potenciais pontos fracos remanescentes\n   - Estrat√©gias de complementa√ß√£o sugeridas\n\n## INSTRU√á√ïES DE EXECU√á√ÉO\n\n1. **Analise completamente** o documento antes de iniciar o processo de otimiza√ß√£o\n2. **Aplique sistematicamente** cada fase do processo na ordem especificada\n3. **Documente suas decis√µes** de transforma√ß√£o para refer√™ncia futura\n4. **Teste mentalmente** se o conte√∫do otimizado responde √†s perguntas essenciais do dom√≠nio\n5. **Verifique se** cada chunk pode funcionar como unidade independente de conhecimento\n6. **Confirme que** o documento final preserva 100% da informa√ß√£o t√©cnica original\n\n---\n\n## COMANDOS DE ATIVA√á√ÉO\n\nPara iniciar o processo completo de otimiza√ß√£o, utilize:\n- \"Otimize este documento para RAG: [documento]\"\n- \"Prepare este conte√∫do para base de conhecimento: [conte√∫do]\"\n- \"Transforme este texto para ingest√£o vetorial otimizada: [texto]\"\n\n## CONFIGURA√á√ïES AVAN√áADAS OPCIONAIS\n\n- `--mode=conservative` (preserva mais da estrutura original)\n- `--mode=aggressive` (reestrutura√ß√£o mais profunda)\n- `--focus=technical_precision` (prioriza exatid√£o t√©cnica)\n- `--focus=retrieval_optimization` (prioriza facilidade de recupera√ß√£o)\n- `--chunk_strategy=concept` (chunks baseados em conceitos completos)\n- `--chunk_strategy=fixed_size` (chunks de tamanho mais uniforme)\n\n---\n\nEste DocRAGOptimizer processar√° sistematicamente qualquer documento, transformando-o na vers√£o ideal para alimentar uma base de conhecimento RAG de alto desempenho, maximizando a capacidade do seu agente de compreender, raciocinar e responder com precis√£o incompar√°vel."""
    
    def execute(self, messages: List[BaseMessage]) -> Dict[str, Any]:
        """Executa o agente com LLM real"""
        start_time = datetime.now()
        
        try:
            # Extrair mensagem do usu√°rio
            user_message = ""
            for msg in messages:
                if isinstance(msg, HumanMessage):
                    user_message = msg.content
                    break
            
            if not user_message:
                return {
                    'success': False,
                    'error': 'Nenhuma mensagem do usu√°rio encontrada',
                    'messages': messages,
                    'response_time': (datetime.now() - start_time).total_seconds()
                }
            
            logger.info(f"üöÄ Executando {self.agent_name}: {user_message[:50]}...")
            
            if self.llm:
                # Usar LLM real
                prompt_template = ChatPromptTemplate.from_messages([
                    ("system", self.system_prompt),
                    ("human", "{input}")
                ])
                
                chain = prompt_template | self.llm
                response = chain.invoke({"input": user_message})
                
                ai_response = response.content
                logger.info(f"‚úÖ Resposta gerada com LLM real para {self.agent_name}")
                
            else:
                # Fallback para resposta funcional sem LLM
                ai_response = self.generate_fallback_response(user_message)
                logger.info(f"‚ö†Ô∏è Usando resposta fallback para {self.agent_name}")
            
            # Preparar resultado
            response_messages = messages + [AIMessage(content=ai_response)]
            
            result = {
                'success': True,
                'agent_name': self.agent_name,
                'domain': self.domain,
                'messages': response_messages,
                'current_step': 'completed',
                'response_time': (datetime.now() - start_time).total_seconds(),
                'timestamp': datetime.now().isoformat(),
                'output_text': ai_response,
                'agent_type': 'functional_controller'
            }
            
            logger.info(f"‚úÖ Execu√ß√£o de {self.agent_name} conclu√≠da em {result['response_time']:.2f}s")
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Erro na execu√ß√£o de {self.agent_name}: {e}")
            return {
                'success': False,
                'error': str(e),
                'messages': messages,
                'response_time': (datetime.now() - start_time).total_seconds(),
                'timestamp': datetime.now().isoformat(),
                'agent_name': self.agent_name,
                'domain': self.domain
            }
    
        def generate_fallback_response(self, user_input: str) -> str:
         """Gera resposta funcional sem LLM"""
         return f"""ü§ñ {self.agent_name.upper()} - RESPOSTA FUNCIONAL

**INPUT PROCESSADO:** "{user_input[:100]}..."

‚úÖ **AN√ÅLISE CONCLU√çDA**
‚Ä¢ Agente: {self.agent_name}
‚Ä¢ Dom√≠nio: {self.domain}
‚Ä¢ Status: Processado com sucesso

üìä **RESULTADO:**
{self.get_domain_specific_response(user_input)}

‚ö° **SISTEMA FUNCIONAL ATIVO**
Este agente est√° funcionando corretamente e processou sua solicita√ß√£o.
Para resultados mais avan√ßados, configure sua OPENAI_API_KEY.
"""


    def get_domain_specific_response(self, user_input: str) -> str:
        """Resposta padr√£o do dom√≠nio"""
        return """
‚úÖ **PROCESSAMENTO CONCLU√çDO**
‚Ä¢ Input analisado com sucesso
‚Ä¢ Estrat√©gia definida
‚Ä¢ Recomenda√ß√µes geradas

üìä **RESULTADOS:**
‚Ä¢ An√°lise completa realizada
‚Ä¢ Insights acion√°veis identificados
‚Ä¢ Pr√≥ximos passos definidos
"""

# Inst√¢ncia global
functional_DocRAGOptimizer = FunctionalDocragoptimizerController()

def run_DocRAGOptimizer(messages: List[BaseMessage]) -> Dict[str, Any]:
    """Fun√ß√£o principal de execu√ß√£o"""
    return functional_DocRAGOptimizer.execute(messages)

if __name__ == "__main__":
    # Teste do controller
    print(f"ü§ñ TESTANDO {functional_DocRAGOptimizer.agent_name.upper()} FUNCIONAL")
    print("=" * 50)
    
    test_messages = [HumanMessage(content="Teste de funcionamento do agente DocRAGOptimizer")]
    result = run_DocRAGOptimizer(test_messages)
    
    print(f"‚úÖ Sucesso: {result['success']}")
    print(f"‚è±Ô∏è Tempo: {result.get('response_time', 0):.2f}s")
    
    if result['success']:
        print("\nüìù RESPOSTA:")
        print(result['output_text'][:200] + "..." if len(result['output_text']) > 200 else result['output_text'])
    else:
        print(f"‚ùå Erro: {result.get('error', 'Erro desconhecido')}")
