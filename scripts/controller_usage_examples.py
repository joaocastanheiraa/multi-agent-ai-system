#!/usr/bin/env python3
"""
LangGraph Controller Usage Examples

This file demonstrates various ways to use the controllers generated by the 
LangGraph Controller Converter. It provides practical examples for:

- Single controller execution
- Multi-agent orchestration
- Error handling and recovery
- State management and monitoring
- Custom workflow integration

These examples serve as templates for integrating generated controllers 
into production applications.
"""

import sys
import json
from typing import Dict, List, Any, Optional
from pathlib import Path
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage

# Add the domains to the Python path so we can import generated controllers
sys.path.append(str(Path(__file__).parent.parent))

def example_single_controller():
    """
    Example 1: Using a single generated controller
    
    This example shows how to import and use a generated controller
    for a specific agent, handling initialization, execution, and
    result processing.
    """
    print("üéØ Example 1: Single Controller Usage")
    print("=" * 50)
    
    try:
        # Import a generated controller
        from domains.copywriters.agents.paradigm_architect.paradigm_architect_controller import (
            ParadigmArchitectController, create_paradigm_architect_controller
        )
        
        # Method 1: Direct instantiation
        controller = ParadigmArchitectController()
        print(f"‚úÖ Controller initialized: {controller.agent_name}")
        
        # Method 2: Factory function (recommended)
        controller_alt = create_paradigm_architect_controller()
        print(f"‚úÖ Controller initialized via factory: {controller_alt.agent_name}")
        
        # Create test messages
        test_messages = [
            HumanMessage(content="I need help creating a persuasive marketing campaign for a B2B SaaS product"),
            HumanMessage(content="Target audience: CTOs at mid-size companies")
        ]
        
        # Create initial state
        initial_state = {
            "messages": test_messages,
            "current_step": "start",
            "agent_name": "paradigm_architect",
            "analysis_results": {},
            "decisions": {},
            "sub_agent_results": {},
            "verification_status": {},
            "output_data": {},
            "metadata": {"session_id": "example_001"},
            "error_state": None
        }
        
        # Execute the workflow
        print("\nüöÄ Executing workflow...")
        result = controller.graph.invoke(initial_state)
        
        # Process results
        print(f"‚úÖ Workflow completed!")
        print(f"   Final step: {result.get('current_step')}")
        print(f"   Messages processed: {len(result.get('messages', []))}")
        print(f"   Decisions made: {len(result.get('decisions', {}))}")
        
        if result.get('error_state'):
            print(f"‚ùå Error occurred: {result['error_state']}")
        else:
            print("‚úÖ Workflow completed successfully!")
            
    except ImportError as e:
        print(f"‚ùå Could not import controller: {e}")
        print("üí° Ensure you've generated controllers using the converter script first")
        
    except Exception as e:
        print(f"‚ùå Error in example: {e}")

def example_multi_agent_workflow():
    """
    Example 2: Multi-agent workflow orchestration
    
    This example demonstrates how to orchestrate multiple generated
    controllers in a sequential or parallel workflow, passing state
    between different agents.
    """
    print("\nüéØ Example 2: Multi-Agent Orchestration")
    print("=" * 50)
    
    try:
        # Import multiple controllers
        from domains.copywriters.agents.paradigm_architect.paradigm_architect_controller import (
            create_paradigm_architect_controller
        )
        from domains.copywriters.agents.pain_detector.pain_detector_controller import (
            create_pain_detector_controller
        )
        
        # Initialize controllers
        paradigm_controller = create_paradigm_architect_controller()
        pain_controller = create_pain_detector_controller()
        
        print(f"‚úÖ Initialized {paradigm_controller.agent_name}")
        print(f"‚úÖ Initialized {pain_controller.agent_name}")
        
        # Create shared initial state
        shared_messages = [
            HumanMessage(content="Analyze customer pain points for our new productivity tool"),
            HumanMessage(content="Focus on remote work challenges and collaboration issues")
        ]
        
        # Execute paradigm architect first
        print("\nüîÑ Step 1: Paradigm Architecture Analysis")
        paradigm_state = {
            "messages": shared_messages,
            "current_step": "start",
            "agent_name": "paradigm_architect",
            "analysis_results": {},
            "decisions": {},
            "sub_agent_results": {},
            "verification_status": {},
            "output_data": {},
            "metadata": {"workflow": "multi_agent", "step": 1},
            "error_state": None
        }
        
        paradigm_result = paradigm_controller.graph.invoke(paradigm_state)
        print(f"   ‚úÖ Paradigm analysis completed")
        
        # Pass results to pain detector
        print("\nüîÑ Step 2: Pain Point Detection")
        pain_state = {
            "messages": paradigm_result.get("messages", []),
            "current_step": "start", 
            "agent_name": "pain_detector",
            "analysis_results": paradigm_result.get("analysis_results", {}),
            "decisions": paradigm_result.get("decisions", {}),
            "sub_agent_results": {"paradigm_architect": paradigm_result.get("output_data", {})},
            "verification_status": {},
            "output_data": {},
            "metadata": {"workflow": "multi_agent", "step": 2},
            "error_state": None
        }
        
        pain_result = pain_controller.graph.invoke(pain_state)
        print(f"   ‚úÖ Pain detection completed")
        
        # Combine results
        final_result = {
            "workflow_type": "multi_agent",
            "agents_executed": ["paradigm_architect", "pain_detector"],
            "total_messages": len(pain_result.get("messages", [])),
            "combined_decisions": {
                **paradigm_result.get("decisions", {}),
                **pain_result.get("decisions", {})
            },
            "final_state": pain_result
        }
        
        print(f"\nüéä Multi-agent workflow completed!")
        print(f"   Agents executed: {len(final_result['agents_executed'])}")
        print(f"   Total decisions: {len(final_result['combined_decisions'])}")
        
    except ImportError as e:
        print(f"‚ùå Could not import controllers: {e}")
        print("üí° Generate controllers for copywriters domain first")
        
    except Exception as e:
        print(f"‚ùå Error in multi-agent example: {e}")

def example_error_handling():
    """
    Example 3: Error handling and recovery
    
    This example shows how to handle errors gracefully when using
    generated controllers, including state validation, error recovery,
    and logging.
    """
    print("\nüéØ Example 3: Error Handling and Recovery")
    print("=" * 50)
    
    try:
        from domains.copywriters.agents.paradigm_architect.paradigm_architect_controller import (
            create_paradigm_architect_controller
        )
        
        controller = create_paradigm_architect_controller()
        
        # Test with invalid state
        print("üîÑ Testing with invalid state...")
        invalid_state = {
            "messages": "This should be a list, not a string",  # Invalid type
            "current_step": "start",
            "agent_name": "paradigm_architect"
            # Missing required fields
        }
        
        try:
            result = controller.graph.invoke(invalid_state)
            if result.get('error_state'):
                print(f"‚úÖ Error correctly caught: {result['error_state']}")
            else:
                print("‚ö†Ô∏è No error detected (unexpected)")
                
        except Exception as e:
            print(f"‚úÖ Exception correctly raised: {e}")
        
        # Test recovery with corrected state
        print("\nüîÑ Testing recovery with corrected state...")
        corrected_state = {
            "messages": [HumanMessage(content="Test message")],
            "current_step": "start",
            "agent_name": "paradigm_architect",
            "analysis_results": {},
            "decisions": {},
            "sub_agent_results": {},
            "verification_status": {},
            "output_data": {},
            "metadata": {},
            "error_state": None
        }
        
        result = controller.graph.invoke(corrected_state)
        if result.get('error_state'):
            print(f"‚ùå Unexpected error: {result['error_state']}")
        else:
            print("‚úÖ Recovery successful!")
            
    except Exception as e:
        print(f"‚ùå Error in error handling example: {e}")

def example_state_monitoring():
    """
    Example 4: State monitoring and debugging
    
    This example demonstrates how to monitor controller execution,
    track state changes, and debug workflow issues.
    """
    print("\nüéØ Example 4: State Monitoring and Debugging")
    print("=" * 50)
    
    try:
        from domains.copywriters.agents.paradigm_architect.paradigm_architect_controller import (
            create_paradigm_architect_controller
        )
        
        controller = create_paradigm_architect_controller()
        
        # Create initial state with debugging enabled
        initial_state = {
            "messages": [HumanMessage(content="Debug workflow execution")],
            "current_step": "start",
            "agent_name": "paradigm_architect",
            "analysis_results": {},
            "decisions": {},
            "sub_agent_results": {},
            "verification_status": {},
            "output_data": {},
            "metadata": {"debug": True, "trace_steps": True},
            "error_state": None
        }
        
        print("üîç Monitoring workflow execution...")
        
        # Execute with state tracking
        result = controller.graph.invoke(initial_state)
        
        # Analyze execution trace
        print("\nüìä Execution Analysis:")
        print(f"   Final step: {result.get('current_step', 'unknown')}")
        print(f"   Steps completed: {len(result.get('decisions', {}))}")
        print(f"   Messages generated: {len(result.get('messages', []))}")
        
        # Show decision trace
        decisions = result.get('decisions', {})
        if decisions:
            print("\nüîç Decision Trace:")
            for step, decision in decisions.items():
                print(f"   {step}: {decision.get('description', 'No description')[:50]}...")
        
        # Show metadata
        metadata = result.get('metadata', {})
        if metadata:
            print("\nüìã Execution Metadata:")
            for key, value in metadata.items():
                print(f"   {key}: {value}")
                
    except Exception as e:
        print(f"‚ùå Error in monitoring example: {e}")

def example_custom_integration():
    """
    Example 5: Custom workflow integration
    
    This example shows how to integrate generated controllers into
    custom workflows, including preprocessing, postprocessing, and
    custom state management.
    """
    print("\nüéØ Example 5: Custom Workflow Integration")
    print("=" * 50)
    
    class CustomWorkflowManager:
        """Custom workflow manager that integrates generated controllers"""
        
        def __init__(self):
            self.controllers = {}
            self.execution_history = []
            
        def register_controller(self, name: str, controller):
            """Register a controller for use in workflows"""
            self.controllers[name] = controller
            print(f"‚úÖ Registered controller: {name}")
            
        def preprocess_state(self, raw_input: str) -> Dict[str, Any]:
            """Preprocess raw input into proper state format"""
            return {
                "messages": [HumanMessage(content=raw_input)],
                "current_step": "start",
                "agent_name": "custom_workflow",
                "analysis_results": {},
                "decisions": {},
                "sub_agent_results": {},
                "verification_status": {},
                "output_data": {},
                "metadata": {"preprocessed": True},
                "error_state": None
            }
            
        def postprocess_result(self, result: Dict[str, Any]) -> str:
            """Extract useful output from controller result"""
            messages = result.get('messages', [])
            if messages:
                last_message = messages[-1]
                return last_message.content if hasattr(last_message, 'content') else str(last_message)
            return "No output generated"
            
        def execute_workflow(self, controller_name: str, input_text: str) -> str:
            """Execute a complete workflow with pre/post processing"""
            if controller_name not in self.controllers:
                return f"Controller '{controller_name}' not found"
                
            # Preprocess
            state = self.preprocess_state(input_text)
            
            # Execute
            controller = self.controllers[controller_name]
            result = controller.graph.invoke(state)
            
            # Log execution
            self.execution_history.append({
                "controller": controller_name,
                "input": input_text[:50] + "..." if len(input_text) > 50 else input_text,
                "success": result.get('error_state') is None,
                "timestamp": result.get('metadata', {}).get('timestamp', 'unknown')
            })
            
            # Postprocess
            return self.postprocess_result(result)
    
    try:
        # Create workflow manager
        workflow_manager = CustomWorkflowManager()
        
        # Register controllers
        from domains.copywriters.agents.paradigm_architect.paradigm_architect_controller import (
            create_paradigm_architect_controller
        )
        
        paradigm_controller = create_paradigm_architect_controller()
        workflow_manager.register_controller("paradigm_architect", paradigm_controller)
        
        # Execute custom workflow
        print("\nüöÄ Executing custom workflow...")
        result = workflow_manager.execute_workflow(
            "paradigm_architect",
            "Help me develop a revolutionary approach to customer onboarding"
        )
        
        print(f"‚úÖ Workflow result: {result}")
        print(f"üìä Execution history: {len(workflow_manager.execution_history)} workflows executed")
        
    except Exception as e:
        print(f"‚ùå Error in custom integration example: {e}")

def main():
    """Run all usage examples"""
    print("üéØ LangGraph Controller Usage Examples")
    print("=" * 60)
    print("This script demonstrates various ways to use generated controllers")
    print()
    
    # Run all examples
    example_single_controller()
    example_multi_agent_workflow()
    example_error_handling()
    example_state_monitoring()
    example_custom_integration()
    
    print("\nüéä All examples completed!")
    print("\nüí° Tips for using generated controllers:")
    print("   1. Always validate state structure before execution")
    print("   2. Handle errors gracefully with try-catch blocks")
    print("   3. Monitor execution state for debugging")
    print("   4. Use factory functions for controller instantiation")
    print("   5. Pass state between agents for orchestration")

if __name__ == "__main__":
    main() 